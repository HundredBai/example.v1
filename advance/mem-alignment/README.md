# 内存对齐

CPU 把内存当成是一块一块的，块的大小可以是 2，4，8，16 字节大小，因此 CPU 在读取内存时是一块一块进行读取的。
- 64 位系统 1 个机器字节等于 8 个字节
- 32 位系统 1 个机器字节等于 4 个字节

为什么要内存对齐？
会了关于结构体内存大小的计算，可是为什么系统要对于结构体数据进行内存对齐，很明显所占用的空间大小要更多。原因可归纳如下：

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

![mem-alignment](mem-alignment.png)

上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。
因此 CPU 会做一些额外的处理工作。如下：

1. CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0
2. CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节
3. 合并 1-4 字节的数据
4. 合并后放入寄存器

从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作

而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的空间换时间做法