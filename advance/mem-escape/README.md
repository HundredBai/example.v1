# 逃逸分析

Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 new、make 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：

- 指向栈对象的指针不能存在于堆中；
- 指向栈对象的指针不能在栈对象回收后存活；

典型情况：

- **在方法内把局部变量指针返回**局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，
  因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中**。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。
  所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值**。 一个典型的例子就是 `[]*string` 。这会导致切片的内容逃逸。尽管其后面的
  数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )**。 slice 初始化的地方在编译时是
  可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法**。 在 `interface` 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行
  时知道。想像一个 `io.Reader` 类型的变量 r , 调用 `r.Read(b)` 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。 
- **数据类型不确定**
- **栈空间不足**
- **变量大小不确定**
  
**逃逸分析最大的好处应该是减少 gc 的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要 gc 标记清除**。